\documentclass[oneside]{homework} %%Change `twoside' to `oneside' if you are printing only on the one side of each sheet.
\usepackage{setspace} 
\usepackage{algorithm} 
\usepackage{algorithmic}
\usepackage{multicol}
\usepackage{epsfig}
\renewcommand{\algorithmicrequire}{\textbf{Require:}}
\renewcommand{\algorithmicensure}{\textbf{Iteration:}}
\renewcommand{\algorithmiclastcon}{\textbf{Output:}}
\studname{Cheng Liu}
\collaborator{Introduction to algorithms\\}
\coursename{Analysis of algorithms I}
\hwNo{5}
\uni{cl3173}
\cuni{3rd edition}
\prNo{3}
\begin{document}
\maketitle
\newpage
\section*{Exercise 22.2-6}
The counter example is quite simple, we just need to find a graph that from vertex v there are multiple shortest paths to a certain destination w with the same depth,then these paths cannot be all selected in the BFS because there is only no more than one edge to a certain vertex can be selected by BFS algorithm. Under such condition, we can always produce a $E_{\pi}$ that not all the edges can be generated by a single run of BFS. 

From Figure \ref{fig:ce1}, we select edges 1,2,3,4 as the elements in $E_{\pi}$, then 3,4 can never be produced by BFS simultaneously.

As a illustration, if in the adjacent list, A is before B, then 6 will be in $E_{\pi}$ instead of 4, otherwise, 5 will be in $E_{\pi}$

\begin{figure}[hc]
  \centering
  \epsfig{figure=./counterexample_2226_1.eps,scale = 1}
  \caption{Counter Example}
  \label{fig:ce1}
\end{figure}



\section*{Exercise 22.2-7}
The algorithm can be explained as this way,we consider each wrestler as a vertex in a graph, and the rivalry relationship as a edge between two vertices, The additional property is that if there is a edge between vertex i and j, then i,j must be in different characters, that is, a babyface and a heel.

Thus we can take advantage of BFS algorithm to produce such a designation. During the progress of BFS, we just assign each vertex with a additional property to indicate its character when first time we reach it, and for each edge we just check whether the two vertices have different character, if it is not, it means that no such designation exists.

We should run BFS multiple times to make sure all the vertices be accessed. 

The time complexity is just the same as multiple BFSs to traverse all the graph is $O(n+r)$, during BFS, we just add a constant time consuming procedure to assign its character and check if it conflicts the requirement.

To prove the correctness of our designation algorithm, if our algorithm gives a designation, for its process, the destination must meet all the requirements of the problem, thus it is a right answer. 

If there exist right answers and we algorithm doesn't find it, the situation is impossible. W.L.O.G, we assume the graph is connected. If our algorithm doesn't find a answer, there must be at least one edge whose vertices with different character, and we denote it with vertex $\mathit{i}, \mathit{j}$, and their characters assigned by our algorithm are Babyface. 

Obviously,  $\mathit{i}, \mathit{j}$ won't be start point,otherwise they won't conflict,then there must be edges $e_{i}{k}$ and $e_{j}{k}$ with a $\mathit{k}$ whose character is heel and .

If the right designation exists, there must a compatible assignment three vertices $\mathit{i}, \mathit{j}$ and $\mathit{k}$, each two of them must be different character, that is obviously impossible.

Then the right designation won't exist. 

\begin{algorithm}[h]
  \caption{Rival Designation}
  \label{algo:rd}
  \begin{algorithmic}[1]
	\REQUIRE G
	\ENSURE ~ ~\\ 
	\FOR {each vertex $\mathit{u} \in G.V$ }
	  \STATE {$\mathit{u}.color = WHITE$}
	  \STATE {$\mathit{u}.d = \infty$}
	  \STATE {$\mathit{u}.character = NONE $}
	  \STATE {$\mathit{u}.\pi = NIL$}
	\ENDFOR
	\WHILE {there is still vertex $\mathit{s}$.color == WHITE in G }
	  \STATE {$\mathit{s}.color = GRAY$}
	  \STATE {$\mathit{s}.d = 0$}
	  \STATE {$\mathit{s}.character = BABYFACE $}
	  \STATE {$\mathit{s}.\pi = NIL$}
	  \STATE {flag = RivalDesignationBFS(G,s)}
	  \IF{flag == 1}
		\STATE {RETURN}
	  \ENDIF
	\ENDWHILE
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
  \caption{RivalDesignationBFS}
  \label{algo:rdBFS}
  \begin{algorithmic}[1]
	\REQUIRE G,s
	\ENSURE ~ ~\\ 
	\STATE {$flag = 0$}
	\STATE {$\mathit{Q} = \emptyset $}
	\STATE {ENQUEUE($\mathit{Q},\mathit{s}$)}
	\WHILE {$\mathit{Q}\neq \emptyset$ }
	  \FOR {each vertex $\mathit{v} \in G.Adj[\mathit{u}]$}
		\IF{$\mathit{v}.character == NONE $}
		  \IF{$\mathit{u}.character == BABYFACE $}
			\STATE {$\mathit{v}.character == HEEL $}
		  \ELSE
			\STATE {$\mathit{v}.character == BABYFACE $}
		  \ENDIF
		\ELSIF {($\mathit{u}.character$==BABYFACE And $\mathit{v}.character$==BABYFACE) Or ($\mathit{u}.character$==HEEL And $\mathit{v}.character$==HEEL)}
			\STATE {$flag = 1$}
			\STATE {RETURN}
		\ENDIF
		\IF {$\mathit{v}.color = WHITE$}
		  \STATE {$\mathit{v}.d =\mathit{u}.d+1 $}
		  \STATE {$\mathit{v}.color = GRAY $}
		  \STATE {$\mathit{v}.\pi = \mathit{u}$}
		\ENDIF
	  \ENDFOR
	  \STATE{$\mathit{u}.color = BLACK$}
	\ENDWHILE
	\LASTCON flag
  \end{algorithmic}
\end{algorithm}


\end{document}
